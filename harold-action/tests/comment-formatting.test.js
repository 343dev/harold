/**
 * Unit Ñ‚ÐµÑÑ‚Ñ‹ Ð´Ð»Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ ÐºÐ¾Ð¼Ð¼ÐµÐ½Ñ‚Ð°Ñ€Ð¸ÐµÐ²
 */

// ÐœÐ¾ÐºÐ°ÐµÐ¼ Ð¼Ð¾Ð´ÑƒÐ»ÑŒ comment.cjs Ð´Ð»Ñ Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¾Ñ‚Ð´ÐµÐ»ÑŒÐ½Ñ‹Ñ… Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹
jest.mock('fs');
const fs = require('node:fs');

describe('Comment Formatting Functions', () => {
	// Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚Ð¸Ñ€ÑƒÐµÐ¼ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸ Ð´Ð»Ñ Ñ‚ÐµÑÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ
	// ÐŸÐ¾ÑÐºÐ¾Ð»ÑŒÐºÑƒ comment.cjs ÑÐºÑÐ¿Ð¾Ñ€Ñ‚Ð¸Ñ€ÑƒÐµÑ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ main Ñ„ÑƒÐ½ÐºÑ†Ð¸ÑŽ, ÑÐ¾Ð·Ð´Ð°Ð´Ð¸Ð¼ Ñ‚ÐµÑÑ‚Ð¾Ð²Ñ‹Ðµ Ð²ÐµÑ€ÑÐ¸Ð¸

	describe('formatComment', () => {
		const formatComment = ({ title, output, baseCommit, headCommit, baseBranch, headBranch, hasChanges, timestamp }) => {
			const statusEmoji = hasChanges ? 'ðŸ“Š' : 'âœ…';
			const statusText = hasChanges ? 'Changes detected' : 'No changes';

			return `## ${statusEmoji} ${title}

**Base:** \`${baseBranch}\` (${baseCommit})
**Head:** \`${headBranch}\` (${headCommit})
**Status:** ${statusText}

\`\`\`
${output}
\`\`\`

---
<sub>Generated by [Harold Action](https://github.com/343dev/harold) â€¢ Updated ${new Date(timestamp).toLocaleString()}</sub>`;
		};

		test('should format comment with changes', () => {
			const parameters = {
				title: 'ðŸ“Š Bundle Size Report',
				output: 'Total: +1.2 kB (+300 B)',
				baseCommit: 'abc1234',
				headCommit: 'def5678',
				baseBranch: 'main',
				headBranch: 'feature/test',
				hasChanges: true,
				timestamp: '2024-01-01T12:00:00.000Z',
			};

			const result = formatComment(parameters);

			expect(result).toContain('## ðŸ“Š ðŸ“Š Bundle Size Report');
			expect(result).toContain('**Base:** `main` (abc1234)');
			expect(result).toContain('**Head:** `feature/test` (def5678)');
			expect(result).toContain('**Status:** Changes detected');
			expect(result).toContain('Total: +1.2 kB (+300 B)');
			expect(result).toContain('Generated by [Harold Action]');
		});

		test('should format comment without changes', () => {
			const parameters = {
				title: 'ðŸ“Š Bundle Size Report',
				output: 'No changes detected',
				baseCommit: 'abc1234',
				headCommit: 'def5678',
				baseBranch: 'main',
				headBranch: 'feature/test',
				hasChanges: false,
				timestamp: '2024-01-01T12:00:00.000Z',
			};

			const result = formatComment(parameters);

			expect(result).toContain('## âœ… ðŸ“Š Bundle Size Report');
			expect(result).toContain('**Status:** No changes');
			expect(result).toContain('No changes detected');
		});

		test('should handle special characters in branch names', () => {
			const parameters = {
				title: 'ðŸ“Š Bundle Size Report',
				output: 'Test output',
				baseCommit: 'abc1234',
				headCommit: 'def5678',
				baseBranch: 'release/v1.0.0',
				headBranch: 'feature/fix-bug-#123',
				hasChanges: true,
				timestamp: '2024-01-01T12:00:00.000Z',
			};

			const result = formatComment(parameters);

			expect(result).toContain('**Base:** `release/v1.0.0` (abc1234)');
			expect(result).toContain('**Head:** `feature/fix-bug-#123` (def5678)');
		});

		test('should handle empty output', () => {
			const parameters = {
				title: 'ðŸ“Š Bundle Size Report',
				output: '',
				baseCommit: 'abc1234',
				headCommit: 'def5678',
				baseBranch: 'main',
				headBranch: 'feature/test',
				hasChanges: false,
				timestamp: '2024-01-01T12:00:00.000Z',
			};

			const result = formatComment(parameters);

			expect(result).toContain('```\n\n```');
		});
	});

	describe('parseHaroldOutput', () => {
		const parseHaroldOutput = output => {
			const result = {
				hasChanges: false,
				totalSizeIncrease: 0,
				totalGzipIncrease: 0,
				percentageIncrease: 0,
				fileChanges: [],
			};

			if (!output || typeof output !== 'string') {
				return result;
			}

			// ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, ÐµÑÑ‚ÑŒ Ð»Ð¸ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ
			if (output.includes('No changes') || output.includes('Snapshots are equal')) {
				return result;
			}

			result.hasChanges = true;

			// Ð˜Ñ‰ÐµÐ¼ ÑÑ‚Ñ€Ð¾ÐºÑƒ Ñ Ð¾Ð±Ñ‰Ð¸Ð¼Ð¸ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸ÑÐ¼Ð¸ (Total)
			const totalMatch = output.match(/total.*?([+-][\d,.]+\s*[gkmt]?b).*?\(([+-][\d,.]+\s*[gkmt]?b)\)/i);

			if (totalMatch) {
				result.totalSizeIncrease = parseSizeString(totalMatch[1]);
				result.totalGzipIncrease = parseSizeString(totalMatch[2]);
			}

			// ÐŸÑ‹Ñ‚Ð°ÐµÐ¼ÑÑ Ð½Ð°Ð¹Ñ‚Ð¸ Ð¿Ñ€Ð¾Ñ†ÐµÐ½Ñ‚Ð½Ð¾Ðµ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ
			const percentMatch = output.match(/([+-]?\d+(?:\.\d+)?)\s*%/);
			if (percentMatch) {
				result.percentageIncrease = Math.abs(Number.parseFloat(percentMatch[1]));
			}

			return result;
		};

		const parseSizeString = sizeString => {
			if (!sizeString || typeof sizeString !== 'string') {
				return 0;
			}

			const match = sizeString.trim().match(/([+-]?)([\d,.]+)\s*([gkmt]?)b?/i);

			if (!match) {
				return 0;
			}

			const sign = match[1] === '-' ? -1 : 1;
			const number = Number.parseFloat(match[2].replaceAll(',', ''));
			const unit = match[3].toUpperCase();

			if (isNaN(number)) {
				return 0;
			}

			let bytes = number;
			switch (unit) {
				case 'K': { bytes *= 1024; break;
				}

				case 'M': { bytes *= 1024 * 1024; break;
				}

				case 'G': { bytes *= 1024 * 1024 * 1024; break;
				}

				case 'T': { bytes *= 1024 * 1024 * 1024 * 1024; break;
				}
			}

			return Math.abs(bytes * sign);
		};

		test('should parse output with no changes', () => {
			const output = 'No changes detected';
			const result = parseHaroldOutput(output);

			expect(result.hasChanges).toBe(false);
			expect(result.totalSizeIncrease).toBe(0);
			expect(result.percentageIncrease).toBe(0);
		});

		test('should parse output with size increases', () => {
			const output = 'Total: +1.2 kB (+300 B)';
			const result = parseHaroldOutput(output);

			expect(result.hasChanges).toBe(true);
			expect(result.totalSizeIncrease).toBe(1228.8); // 1.2 * 1024
			expect(result.totalGzipIncrease).toBe(300);
		});

		test('should parse output with percentage', () => {
			const output = 'Total increase: +15.5%';
			const result = parseHaroldOutput(output);

			expect(result.hasChanges).toBe(true);
			expect(result.percentageIncrease).toBe(15.5);
		});

		test('should handle complex Harold output', () => {
			const output = `Total: +2.5 kB (+1.1 kB) - increase of 12.3%
Diff by files:
+ main.js: +1.5 kB (+800 B)
m vendor.js: +1.0 kB (+300 B)`;

			const result = parseHaroldOutput(output);

			expect(result.hasChanges).toBe(true);
			expect(result.totalSizeIncrease).toBe(2560); // 2.5 * 1024
			expect(result.totalGzipIncrease).toBe(1126.4); // 1.1 * 1024
			expect(result.percentageIncrease).toBe(12.3);
		});

		test('should handle empty or invalid input', () => {
			expect(parseHaroldOutput('')).toEqual({
				hasChanges: false,
				totalSizeIncrease: 0,
				totalGzipIncrease: 0,
				percentageIncrease: 0,
				fileChanges: [],
			});

			expect(parseHaroldOutput(null)).toEqual({
				hasChanges: false,
				totalSizeIncrease: 0,
				totalGzipIncrease: 0,
				percentageIncrease: 0,
				fileChanges: [],
			});
		});
	});

	describe('parseSizeString', () => {
		const parseSizeString = sizeString => {
			if (!sizeString || typeof sizeString !== 'string') {
				return 0;
			}

			const match = sizeString.trim().match(/([+-]?)([\d,.]+)\s*([gkmt]?)b?/i);

			if (!match) {
				return 0;
			}

			const sign = match[1] === '-' ? -1 : 1;
			const number = Number.parseFloat(match[2].replaceAll(',', ''));
			const unit = match[3].toUpperCase();

			if (isNaN(number)) {
				return 0;
			}

			let bytes = number;
			switch (unit) {
				case 'K': { bytes *= 1024; break;
				}

				case 'M': { bytes *= 1024 * 1024; break;
				}

				case 'G': { bytes *= 1024 * 1024 * 1024; break;
				}

				case 'T': { bytes *= 1024 * 1024 * 1024 * 1024; break;
				}
			}

			return Math.abs(bytes * sign);
		};

		test('should parse bytes', () => {
			expect(parseSizeString('+500 B')).toBe(500);
			expect(parseSizeString('-300 B')).toBe(300);
			expect(parseSizeString('1000')).toBe(1000);
		});

		test('should parse kilobytes', () => {
			expect(parseSizeString('+1.5 kB')).toBe(1536); // 1.5 * 1024
			expect(parseSizeString('-2 KB')).toBe(2048);
			expect(parseSizeString('0.5 k')).toBe(512);
		});

		test('should parse megabytes', () => {
			expect(parseSizeString('+1 MB')).toBe(1_048_576); // 1024 * 1024
			expect(parseSizeString('2.5 mB')).toBe(2_621_440);
		});

		test('should parse gigabytes', () => {
			expect(parseSizeString('+1 GB')).toBe(1_073_741_824); // 1024^3
		});

		test('should handle comma separators', () => {
			expect(parseSizeString('+1,500 B')).toBe(1500);
			expect(parseSizeString('2,048 kB')).toBe(2_097_152);
		});

		test('should handle invalid input', () => {
			expect(parseSizeString('')).toBe(0);
			expect(parseSizeString('invalid')).toBe(0);
			expect(parseSizeString(null)).toBe(0);
			expect(parseSizeString()).toBe(0);
		});

		test('should return absolute values', () => {
			expect(parseSizeString('-500 B')).toBe(500);
			expect(parseSizeString('+500 B')).toBe(500);
		});
	});

	describe('shouldFailOnIncrease', () => {
		const shouldFailOnIncrease = (output, sizeThreshold, percentageThreshold) => {
			const parseHaroldOutput = output => {
				const result = {
					hasChanges: false,
					totalSizeIncrease: 0,
					percentageIncrease: 0,
				};

				if (!output || output.includes('No changes')) {
					return result;
				}

				result.hasChanges = true;

				const totalMatch = output.match(/([+-][\d,.]+\s*[gkmt]?b)/i);
				if (totalMatch) {
					const sizeString = totalMatch[1];
					const match = sizeString.match(/([+-]?)([\d,.]+)\s*([gkmt]?)b?/i);
					if (match) {
						const number = Number.parseFloat(match[2].replaceAll(',', ''));
						const unit = match[3].toUpperCase();
						let bytes = number;
						if (unit === 'K') {
							bytes *= 1024;
						} else if (unit === 'M') {
							bytes *= 1024 * 1024;
						}

						result.totalSizeIncrease = bytes;
					}
				}

				const percentMatch = output.match(/([+-]?\d+(?:\.\d+)?)\s*%/);
				if (percentMatch) {
					result.percentageIncrease = Math.abs(Number.parseFloat(percentMatch[1]));
				}

				return result;
			};

			try {
				const analysis = parseHaroldOutput(output);

				if (!analysis.hasChanges) {
					return false;
				}

				if (analysis.totalSizeIncrease > sizeThreshold) {
					return true;
				}

				if (analysis.percentageIncrease > percentageThreshold) {
					return true;
				}

				return false;
			} catch {
				return false;
			}
		};

		test('should not fail when no changes', () => {
			const output = 'No changes detected';
			expect(shouldFailOnIncrease(output, 1000, 5)).toBe(false);
		});

		test('should fail when size threshold exceeded', () => {
			const output = 'Total: +2 kB (+500 B)';
			expect(shouldFailOnIncrease(output, 1000, 10)).toBe(true); // 2048 > 1000
		});

		test('should fail when percentage threshold exceeded', () => {
			const output = 'Total increase: +15%';
			expect(shouldFailOnIncrease(output, 10_000, 10)).toBe(true); // 15% > 10%
		});

		test('should not fail when under thresholds', () => {
			const output = 'Total: +500 B - increase of 2%';
			expect(shouldFailOnIncrease(output, 1000, 5)).toBe(false);
		});

		test('should handle parsing errors gracefully', () => {
			const output = 'Invalid output format';
			expect(shouldFailOnIncrease(output, 1000, 5)).toBe(false);
		});
	});
});
